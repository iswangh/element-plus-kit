---
description: 开发规范
globs: 
alwaysApply: true
priority: 2  # 优先级，确保规则被正确执行
tags:
  - code-quality
  - typescript
  - code-style
  - comment
  - testing
  - tool-config
  - architecture
  - development
---

# 开发规范

> **⚠️ 强制要求 - 请勿忽略**
>
> 本文档定义了代码质量、TypeScript 类型、代码风格、注释编写、测试、错误处理、调试诊断、开发工具配置和项目架构规范，所有代码实现必须严格遵循。

## 目录导航

- [代码质量规范](#代码质量规范)
- [代码实现原则](#代码实现原则)
- [TypeScript 类型规范](#typescript-类型规范)
- [代码风格规范](#代码风格规范)
- [注释编写规范](#注释编写规范)
  - [JSDoc 标准](#jsdoc-标准)
  - [注释类型与格式](#注释类型与格式)
  - [注释编写原则](#注释编写原则)
  - [注释优先级](#注释优先级)
  - [注释与类型系统](#注释与类型系统)
- [测试规范](#测试规范)
- [错误处理规范](#错误处理规范)
- [调试诊断规范](#调试诊断规范)
- [开发工具配置规范](#开发工具配置规范)
  - [Node.js 版本管理规范](#nodejs-版本管理规范)
  - [包管理器规范](#包管理器规范)
  - [工具使用规范](#工具使用规范)
  - [安全规范](#安全规范)
  - [兼容性规范](#兼容性规范)
- [项目架构规范](#项目架构规范)
  - [目录结构规范](#目录结构规范)
  - [导出规范](#导出规范)

## 代码质量规范

- 组件保持单一职责原则（SRP），业务逻辑与视图层分离，函数保持纯函数特性
- 提取公共逻辑为独立的工具函数或工具类，公共逻辑放置在 `utils/` 或 `helpers/` 目录
- 遵循 KISS 原则，避免过度设计和过早优化，优先选择简单、直接的实现方案
- 变量、函数、类名需准确描述其用途和含义，避免缩写和单字母变量（循环计数器除外），布尔值使用 `is`、`has`、`should` 等前缀

## 代码实现原则

- 代码质量最高标准（最重要原则）：代码实现必须追求极致的极简性、优雅性、可读性、可维护性、可扩展性和高性能，并严格遵循最新的现代开发习惯和最佳实践。这是代码开发准则中最核心、最重要的要求，所有代码实现都必须以此为标准进行设计和开发，不得妥协
- 实现优先级排序：在满足最佳实践、现代开发习惯和可读性的前提下，优先级为：极简性 > 代码优雅 > 可扩展性 > 性能优化
- 代码可读性至关重要，包括清晰的命名、合理的结构、必要的注释（防止短时间遗忘），不应为了极简或性能而牺牲可读性
- 代码实现必须考虑未来扩展需求，优先使用策略模式、配置化设计、插件化架构等可扩展的设计模式
- 优先使用 ES6+ 标准语法和 API
- 不要为了微小的性能提升而牺牲代码可读性和可维护性，性能优化必须在明确存在性能瓶颈时进行
- 尽可能减少嵌套层级和 else 分支，优先使用提前返回（early return）模式
- 单行条件语句尽可能省略大括号 `{}`，优先使用 `if(xxx) return xxx` 而非 `if(xxx) { return xxx }`，但需确保可读性不受影响
- 优先使用逻辑运算符（`&&`、`||`、`??`），其次使用三元运算符，最后使用 `if-else` 语句，但需确保可读性不受影响
- 优先使用策略模式替代 `if-else` 语句

## TypeScript 类型规范

- 充分利用 TypeScript 的类型推断能力，避免不必要的类型注解
- 命名规范：变量、函数使用 `camelCase`，类、接口、类型别名、枚举使用 `PascalCase`，常量使用 `UPPER_CASE`，私有成员可使用 `_` 前缀
- 优先使用 `interface` 定义对象类型，使用 `type` 定义联合类型、交叉类型或复杂类型
- 启用严格模式（`strict: true`），充分利用类型系统的优势，为第三方库缺失的类型定义添加类型声明文件

## 代码风格规范

- 严格遵循项目配置的代码规范（ESLint、Prettier 等）
- 遵循项目特定的代码风格规则
- 保持整个项目的代码风格统一
- 事件处理函数必须使用 `on` 前缀（如 `onChange`、`onClick`、`onSubmit`），更简洁且符合原生事件命名习惯（`onclick`、`onchange`），禁止使用 `handle` 前缀或其他命名风格

## 注释编写规范

### JSDoc 标准

- 当变量、函数、类、接口的类型定义需要说明时，使用 JSDoc 格式进行注释
- 遵循"注释编写原则"中的必要性原则（必须严格遵循[注释编写原则](#注释编写原则)章节）
- 优先使用 TypeScript 类型系统表达意图，类型系统无法表达时再使用注释补充说明
- 所有对外暴露的公共 API（导出的函数、类、接口、类型等）必须提供完整的 JSDoc 注释

### 注释类型与格式

- 文件开头建议使用 `@file` 标签说明文件用途和相关信息
- 当注释仅包含标题时，使用 `/** xxx */` 单行格式
- 当需要添加描述说明时，使用多行 JSDoc 格式
- 当函数有参数或返回值时，必须使用 `@param` 和 `@returns` 标签（格式：`@param {类型} 参数名 - 参数描述`，`@returns {类型} 返回值描述`）
- 类定义必须包含类的作用、主要方法和使用示例
- Interface 和 Type 定义必须使用 JSDoc 格式
- 枚举定义必须包含枚举的用途说明，每个枚举值必须添加注释
- 函数内部逻辑说明使用 `//` 单行注释格式，注释必须放在被注释代码的上方
- 禁止在代码行尾添加注释，除非是极短的说明（如 `// TODO`）
- TODO 和 FIXME 注释必须包含作者、日期和具体说明，格式：`// TODO(作者名, YYYY-MM-DD): 说明`
- 标记废弃的 API 时，必须使用 `@deprecated` 标签并说明替代方案

### 注释编写原则

- 必要性原则：代码本身能表达清楚的逻辑，优先简化注释而非删除；优先通过良好的命名和代码结构表达意图；只有当注释完全冗余（仅重复代码本身已表达的信息）时才删除；如果注释提供了额外的上下文、说明或重要信息，必须保留但简化
- 注释内容必须与代码实现保持一致
- 修改代码时同步更新相关注释
- 注释简洁明了，避免冗余，优先简化而非删除
- 公共 API 的注释必须完整，包括用途、参数、返回值、异常、示例等
- 禁止使用注释来"注释掉"代码，必须直接删除不需要的代码
- 禁止在注释中重复代码本身已经表达的信息，但必须简化而非直接删除

### 注释优先级

- 高优先级（必须注释）：公共 API、复杂的业务逻辑和算法、非显而易见的实现细节、性能优化和特殊处理
- 中优先级（建议注释）：工具函数和辅助方法、配置项和常量、类型定义和接口
- 低优先级（可选注释）：简单的 getter/setter 方法、自解释的代码、临时变量和局部变量

### 注释与类型系统

- 优先使用 TypeScript 类型系统表达意图，类型系统无法表达时再使用注释
- JSDoc 中的类型注解必须与 TypeScript 类型定义保持一致
- 如果 TypeScript 类型已经足够清晰，JSDoc 中可以不重复类型信息


## 测试规范

- 测试文件组织：测试文件与源文件同目录或 `__tests__` 目录，测试文件命名：`*.test.ts`、`*.spec.ts` 或 `*.test.tsx`
- 测试编写原则：每个测试用例只测试一个功能点，测试用例名称清晰描述测试内容，测试必须独立，不依赖其他测试的执行顺序
- 测试覆盖：核心功能、公共 API、边界情况和错误处理必须有测试覆盖，优先保证质量，再追求覆盖率

## 错误处理规范

- 全面处理边界情况和异常状态
- 提供有意义的错误信息，便于调试和问题定位
- 向用户展示友好的错误提示，避免暴露技术细节

## 调试诊断规范

- 仔细阅读错误信息，使用适当的调试工具，添加适当的日志输出，检查边界情况和异常输入
- 编译错误处理：检查类型定义、导入路径、配置文件是否正确
- 类型错误处理：理解类型错误的根本原因，检查类型定义是否完整，避免使用 `any`
- 运行时错误处理：使用浏览器开发者工具查看错误信息，使用断点调试定位问题，使用 try-catch 捕获和处理异常
- 性能问题诊断：使用性能分析工具识别性能瓶颈，优先优化影响最大的部分

## 开发工具配置规范

### Node.js 版本管理规范

- 优先使用 Volta 管理 Node.js 版本：Volta 必须全局安装，使用前检查是否已安装，优先检查项目中是否已存在 Volta 配置并遵循现有配置（必须使用 `read_file` 工具逐行逐字符读取 `package.json` 文件）
- 备选方案：若 Volta 不可用，使用项目 `package.json` 中的 `engines` 字段或 `.nvmrc` 文件管理 Node.js 版本（必须使用 `read_file` 工具逐行逐字符读取相关配置文件）

### 包管理器规范

- 优先使用 @antfu/ni 智能命令：`@antfu/ni` 必须全局安装，使用前检查是否已安装，使用 `ni` 安装依赖，使用 `nr` 运行脚本命令
- 备选方案：若 ni 不可用，使用 npm 作为备选包管理器
- 执行包管理命令前，优先检查项目根目录的锁文件类型，使用对应的包管理器（必须使用 `read_file` 工具逐行逐字符读取锁文件或使用 `list_dir` 工具检查文件存在性）

### 工具使用规范

- 配置文件查询规范（执行前必查）：
  - 必须读取最新内容：必须使用 `read_file` 工具逐行逐字符读取最新的配置文件内容，禁止使用缓存的配置内容
  - 禁止缓存：每次执行前必须重新逐行逐字符读取配置文件，确保使用最新的配置信息
  - 读取时机：脚本执行前逐行逐字符读取 `package.json` 的 `scripts` 字段，依赖操作前逐行逐字符读取 `dependencies`、`devDependencies`、`peerDependencies`、`engines`、`volta` 字段，构建配置前逐行逐字符读取相关配置文件，环境配置前逐行逐字符读取 `.env.example`、`.env` 或 `.env.local`，工具配置前逐行逐字符读取 `.editorconfig`、`.gitignore`、`.npmrc` 或 `.pnpmrc`
- 脚本执行规范：
  - 必须读取最新内容：执行脚本前必须先使用 `read_file` 工具逐行逐字符读取 `package.json` 的 `scripts` 字段，禁止使用缓存的脚本信息
  - 环境检测：检测当前运行环境并根据环境生成对应的命令
  - 命令选择：运行脚本时优先使用 `@antfu/ni` 提供的 `nr` 命令，若 `nr` 不可用，根据项目锁文件类型使用对应的包管理器命令
- 配置修改：
  - 必须读取最新内容：修改配置前，必须先使用 `read_file` 工具逐行逐字符读取相关配置文件的最新内容，禁止使用缓存的配置内容
  - 理解现有配置：逐行逐字符理解现有配置后再进行修改
  - 测试验证：修改后测试确保配置生效

### 安全规范

- 不在代码中硬编码敏感信息，使用环境变量管理敏感信息，确保 `.gitignore` 正确配置
- 定期检查依赖的安全漏洞，使用 `pnpm audit` 或类似工具检查，及时更新有安全漏洞的依赖

### 兼容性规范

- 明确项目支持的浏览器版本，使用 Babel 或类似工具处理兼容性，测试主要浏览器的兼容性
- 明确项目的 Node.js 版本要求和包管理器版本要求，在文档中明确说明版本要求

## 项目架构规范

### 目录结构规范

- 按业务领域或功能模块划分目录，严格遵循关注点分离原则
- 采用描述性命名，目录和文件名需清晰反映其用途和职责
- 相关功能聚合到同一模块，保持高内聚，最小化跨模块依赖，每个模块职责明确
- 每个模块必须包含 `index.ts`（或 `index.tsx`）作为聚合导出入口，禁止在模块外部直接导入模块内部文件
- 目录嵌套深度不超过 5-6 层
- 严格区分源代码（`src/`）、静态资源（`public/` 或 `assets/`）、配置文件（`configs/`）和测试文件（`tests/` 或 `__tests__/`）
- 使用 `.env` 文件管理环境变量，在 `.gitignore` 中忽略包含敏感信息的文件，提供 `.env.example` 文件作为模板
- 优先遵循项目现有的结构和命名约定，其次采用框架官方推荐的项目结构

### 导出规范

- 模块索引文件（`index.ts` 或 `index.tsx`）进行聚合导出时，必须使用 `export * from 'xxx'` 和 `export type * from 'xxx'` 格式
- 类型导出使用 `export type * from 'xxx'`，值导出使用 `export * from 'xxx'`，确保类型和值正确分离
- 仅在需要限制某些方法或类型为内部使用时，才使用具名导出（`export { xxx } from 'xxx'`），其他情况一律使用通配符导出
- 所有需要对外暴露的公共 API 都通过索引文件正确导出
- 同一模块内的导出方式必须统一
