---
description: Monorepo 开发通用规范
globs: 
alwaysApply: true
---

# Monorepo 开发通用规范

## Monorepo 架构概述

### Monorepo 结构模式
- **包管理工具**：pnpm workspace、npm workspace、yarn workspace、bun workspace、Lerna 等
- **包组织方式**：
  - `packages/` - 可发布的包
  - `apps/` - 应用程序
  - `tools/` - 工具脚本
  - `playground/` - 开发测试环境
  - `docs/` - 文档站点

---

## 包管理工具规范

### 工具选择
- **推荐使用 pnpm workspace**（最成熟稳定）：
  - 磁盘空间效率高（硬链接）
  - 安装速度快
  - 严格的依赖解析
  - 支持 workspace 协议
  - 完善的工具链和社区支持
- **备选方案**（按成熟度排序）：
  - npm workspace（npm 7+）：官方支持，稳定可靠
  - yarn workspace（Yarn 1.x 或 Yarn Berry）：成熟稳定，功能完善
  - bun workspace（Bun 1.0+）：新兴工具，性能优秀，但相对较新

### 工作区配置
- **配置文件**：
  - `pnpm-workspace.yaml`（pnpm）
  - `package.json` 的 `workspaces` 字段（npm/yarn/bun）
- **配置原则**：
  - 明确指定工作区路径，使用通配符匹配（如 `packages/*`）
  - 排除不需要的目录（如 `node_modules`、`dist`）
  - 确保工作区路径与实际目录结构一致
  - 工作区配置应提交到版本控制

### 依赖管理
- **内部依赖**：
  - 使用 `workspace:*` 协议引用工作区内的包
  - 示例：`"@org/package-name": "workspace:*"`
  - 发布时会自动替换为具体版本号
  - 确保内部依赖版本与工作区包版本一致
- **外部依赖**：
  - 使用 `peerDependencies` 声明共享依赖（如 Vue、React 等框架）
  - 避免在多个包中重复安装相同的依赖
  - 由使用者提供依赖版本，避免版本冲突
  - 在根目录统一管理共享依赖的版本
- **开发依赖**：
  - 统一放在根目录的 `devDependencies`（推荐）
  - 或放在各包的 `devDependencies`（包特定的工具）
  - 严格区分运行时依赖和开发时依赖
- **锁文件管理**：
  - 锁文件（如 `pnpm-lock.yaml`、`package-lock.json`、`yarn.lock`）必须提交到版本控制
  - 确保团队成员使用相同的依赖版本
  - 定期更新锁文件，保持依赖最新

---

## 包命名和结构规范

### 包命名规范
- **Scoped Package**：推荐使用作用域包（如 `@org/package-name`）
- **命名原则**：
  - 清晰描述包的功能和用途
  - 保持命名一致性和可预测性
  - 避免过长的名称，保持简洁
  - 使用 kebab-case 或 camelCase（根据项目约定）

### 包目录结构
```
packages/[package-name]/
├── src/              # 源代码目录
│   ├── index.ts      # 主入口文件
│   └── ...           # 其他源文件
├── dist/             # 构建产物（不提交）
├── package.json      # 包配置
├── tsconfig.json     # TypeScript 配置
├── vite.config.ts    # 构建配置（可选）
└── README.md         # 包文档
```

### 包入口规范
- **主入口**：`src/index.ts` 统一导出所有公共 API，避免在模块外部直接导入模块内部文件，通过 `index.ts` 统一管理模块的对外接口（参考 000 规范）
- **类型导出**：
  - 通过 `package.json` 的 `exports.types` 字段
  - 确保类型文件在构建时正确生成
  - 类型文件路径正确指向 `dist/` 目录
- **样式导出**：
  - 通过 `package.json` 的 `exports` 字段（如 `./style.css`）
  - 支持按需导入样式文件
  - 样式文件应单独导出，便于按需使用
- **多入口支持**：
  - 可通过 `exports` 字段定义多个入口点
  - 每个入口点应明确指定 `types`、`import`、`require` 等字段
  - 保持入口点命名清晰，反映其用途

---

## 包依赖关系规范

### 依赖声明
- **内部依赖**：参考"依赖管理"章节中的"内部依赖"部分
- **外部依赖**：参考"依赖管理"章节中的"外部依赖"部分
- **开发依赖**：参考"依赖管理"章节中的"开发依赖"部分

### 依赖顺序
- **构建顺序**：
  - 按照依赖关系顺序构建（从底层到上层）
  - 确保被依赖的包先构建完成
  - 使用构建工具自动处理依赖顺序（如 pnpm filter、npm-run-all）
  - 构建失败时，检查依赖包的构建状态
- **发布顺序**：
  - 按照依赖关系顺序发布（从底层到上层）
  - 发布前确保依赖包已发布到注册表
  - 使用发布工具自动处理依赖顺序（如 changesets、Lerna）
  - 发布后验证依赖包版本是否正确更新

### 循环依赖
- **禁止循环依赖**：包之间不能形成循环依赖
- **依赖图**：
  - 保持清晰的依赖关系图
  - 使用工具（如 `pnpm why`）检查依赖关系
  - 定期审查依赖关系，避免不必要的依赖

---

## TypeScript 配置规范

### 项目引用（Project References）
- **使用 TypeScript Project References** 管理包之间的类型依赖
- **配置原则**：
  - 根目录配置基础 `tsconfig.json`，定义共享配置
  - 各包继承基础配置，启用 `composite: true`
  - 通过 `references` 字段声明依赖关系
  - 使用 `tsBuildInfoFile` 指定增量编译信息文件路径
  - 确保类型检查时能正确解析跨包类型引用

### 类型定义导出
- **导出方式**：
  - 通过 `package.json` 的 `exports.types` 字段
  - 确保类型文件路径正确指向 `dist/` 目录
- **生成方式**：
  - 构建时自动生成（使用 `vite-plugin-dts`、`rollup-plugin-dts` 等）
  - 生成 `.d.ts` 和 `.d.ts.map` 文件
- **类型文件位置**：
  - 类型文件位于 `dist/` 目录
  - 保持与源码结构一致的目录结构
- **类型引用**：
  - 通过 TypeScript Project References 管理包之间的类型依赖
  - 确保类型定义在包之间正确传递

---

## 构建和发布规范

### 构建配置
- **构建工具**：Vite、Rollup、Webpack 等
- **构建模式**：
  - 使用库模式（Library Mode）
  - 输出 ES 模块格式（推荐）或 UMD 格式
- **外部依赖**：
  - 使用 `external` 配置，避免打包外部依赖
  - 将 `peerDependencies` 和内部依赖都标记为外部依赖
  - 减少构建产物体积，避免依赖重复打包

### 构建产物
- **输出目录**：`dist/`（每个包的 `dist/` 目录都应在 `.gitignore` 中排除）
- **Git 忽略配置**：
  - 在根目录 `.gitignore` 中添加 `**/dist/` 或 `packages/*/dist/`
  - 确保所有包的构建产物目录都被排除，不提交到版本控制
- **包含文件**：`.js`、`.d.ts`、`.d.ts.map`、样式文件等
- **文件组织**：
  - 保持与源码结构一致的目录结构
  - 确保构建产物可以直接使用
  - 样式文件单独输出，支持按需导入

### 发布流程
- **发布前检查**：
  - 自动执行 `prepublishOnly`（构建 + 类型检查）
  - 确保所有测试通过
  - 检查版本号是否正确更新
- **版本管理**：
  - **版本格式**：遵循语义化版本（SemVer）（参考 000 规范）
  - **版本策略**：独立版本（每个包独立管理版本号）或统一版本（所有包共享版本号，根据项目需求选择）
- **发布顺序**：
  - 按照依赖顺序发布（从底层到上层）
  - 发布后验证依赖包版本是否正确更新
  - 使用发布工具自动处理依赖顺序和版本更新

---

## 开发工作流规范

### 根目录脚本配置
- **多包脚本管理**：在项目根目录的 `package.json` 中添加运行或打包多个包的脚本，方便统一管理
- **脚本示例**：
  ```json
  {
    "scripts": {
      "dev": "run-p \"dev:packages\" \"dev:playground\"",
      "dev:packages": "pnpm --filter \"./packages/*\" dev",
      "build:packages": "pnpm --filter \"./packages/*\" build",
      "publish:all": "run-s publish:package-a publish:package-b publish:package-c"
    }
  }
  ```
- **脚本工具**：
  - **推荐混用**：`npm-run-all` 和 filter 功能配合使用是最佳实践
    - **filter 功能**：用于选择要操作的包（批量或单个包）
    - **npm-run-all**：用于控制多个任务的执行顺序（并行 `run-p` 或串行 `run-s`）
    - **配合示例**：
      - `run-p "dev:packages" "dev:playground"` - 并行执行多个 filter 任务
      - `run-s publish:package-a publish:package-b` - 串行执行多个 filter 任务
      - `pnpm --filter "./packages/*" dev` - 使用 filter 批量操作所有包
  - **备选方案**：`concurrently` 等工具也可用于并行执行，但 `npm-run-all` 更轻量且功能完善
- **脚本命名规范**：
  - 使用统一的命名前缀（如 `dev:`、`build:`、`publish:`）
  - 明确区分单个包操作和批量操作
  - 保持脚本名称清晰易懂
- **脚本组织原则**：
  - 将常用脚本放在根目录，便于快速执行
  - 为每个包提供独立的脚本命令（如 `publish:package-a`、`publish:package-b`）
  - 使用组合脚本简化复杂操作流程

### 开发环境
- **本地开发**：使用 watch 模式自动构建，支持并行构建多个包，使用路径别名直接引用源码避免频繁构建
- **测试环境**：使用 playground 或示例应用进行功能测试，确保测试环境与实际使用环境一致
- **热更新**：通过路径别名直接引用源码支持 HMR，配置构建工具的别名解析确保开发时使用源码，生产构建时使用构建产物

### 调试技巧
- **依赖调试**：
  - 使用 `pnpm why <package>` 或类似命令查看依赖关系
  - 检查依赖版本冲突和重复安装
- **构建调试**：
  - 使用构建工具的详细日志模式（如 `--verbose`）
  - 检查构建顺序和依赖关系
- **类型调试**：
  - 使用 TypeScript 的 `--traceResolution` 查看类型解析过程
  - 检查 Project References 配置是否正确

---

## 最佳实践和注意事项

### 性能优化
- **构建缓存**：利用构建工具的缓存机制（如 Vite 的缓存、TypeScript 的增量编译），避免不必要的重复构建
- **依赖优化**：定期清理未使用的依赖，使用 `pnpm why` 或类似工具分析依赖树
- **并行构建**：充分利用并行构建能力提升构建速度，注意构建顺序确保依赖包先构建完成

### CI/CD 集成
- **构建流程**：在 CI 中按照依赖顺序构建所有包，使用缓存机制加速构建过程
- **测试流程**：为每个包运行独立的测试套件，确保测试环境与实际使用环境一致
- **发布流程**：自动化版本管理和发布流程，使用发布工具（如 changesets）管理版本变更

---
