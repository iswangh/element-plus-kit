---
description: Monorepo 开发通用规范
globs: 
alwaysApply: true
---

# Monorepo 开发通用规范

## Monorepo 架构概述

### Monorepo 结构模式
- **包管理工具**：pnpm workspace、npm workspace、yarn workspace、bun workspace、Lerna 等
- **包组织方式**（推荐目录结构）：
  - `packages/` - 可发布的包（库、组件、工具函数等）
  - `apps/` - 应用程序（前端应用、后端服务等）
  - `tools/` - 工具脚本（构建脚本、CLI 工具等）
  - `playground/` - 开发测试环境（本地开发调试）
  - `docs/` - 文档站点（项目文档、API 文档等）
- **目录命名原则**：使用小写字母和连字符（kebab-case），保持命名简洁清晰

---

## 包管理工具规范

### 工具选择
- **推荐使用 pnpm workspace**（最成熟稳定，优先选择）：
  - **磁盘空间效率高**：通过硬链接（hard link）和符号链接（symlink）机制，避免重复存储相同依赖
  - **安装速度快**：优化的依赖解析算法和并行安装机制
  - **严格的依赖解析**：避免幽灵依赖（phantom dependencies）问题
  - **workspace 协议支持**：原生支持 `workspace:*` 协议，简化内部依赖管理
  - **完善的工具链**：提供丰富的 CLI 命令和 filter 功能
  - **活跃的社区支持**：社区活跃，问题反馈及时
- **备选方案**（按成熟度和稳定性排序）：
  - **npm workspace**（npm 7+）：官方支持，稳定可靠，但磁盘空间效率较低
  - **yarn workspace**（Yarn 1.x 或 Yarn Berry）：成熟稳定，功能完善，但配置相对复杂
  - **bun workspace**（Bun 1.0+）：新兴工具，性能优秀，但生态相对较新，可能存在兼容性问题

### 工作区配置
- **配置文件**：
  - **pnpm**：`pnpm-workspace.yaml` 文件
  - **npm/yarn/bun**：`package.json` 的 `workspaces` 字段
- **配置原则**：
  - **明确指定工作区路径**：使用通配符匹配（如 `packages/*`、`apps/*`），支持多级目录结构
  - **排除不需要的目录**：明确排除 `node_modules`、`dist`、`build` 等构建产物和依赖目录
  - **路径一致性**：确保工作区路径与实际目录结构完全一致，避免路径解析错误
  - **版本控制**：工作区配置文件必须提交到版本控制，确保团队成员配置一致
- **配置示例**（pnpm）：
  ```yaml
  packages:
    - 'packages/*'
    - 'apps/*'
    - 'tools/*'
    - 'playground'
    - 'docs'
  ```

### 依赖管理
- **内部依赖**（工作区包之间的依赖）：
  - **协议使用**：必须使用 `workspace:*` 协议引用工作区内的包
  - **示例格式**：`"@org/package-name": "workspace:*"`
  - **发布处理**：发布到 npm 时会自动将 `workspace:*` 替换为具体版本号
  - **版本一致性**：确保内部依赖版本与工作区包版本保持一致，避免版本不匹配问题
  - **优势**：支持本地开发时直接引用源码，无需发布即可测试
- **外部依赖**（第三方依赖）：
  - **共享依赖声明**：使用 `peerDependencies` 声明共享依赖（如 Vue、React、TypeScript 等框架和工具）
  - **避免重复安装**：避免在多个包中重复安装相同的依赖，减少磁盘空间占用和安装时间
  - **版本管理策略**：由使用者（最终项目）提供依赖版本，避免版本冲突
  - **统一版本管理**：在根目录统一管理共享依赖的版本，确保版本一致性
  - **运行时依赖**：运行时必需的依赖放在 `dependencies`，仅在开发时需要的放在 `devDependencies`
- **开发依赖**（开发工具和构建工具）：
  - **推荐方案**：统一放在根目录的 `devDependencies`，便于统一管理和版本控制
  - **备选方案**：包特定的工具可以放在各包的 `devDependencies`（如某个包特有的测试工具）
  - **严格区分**：严格区分运行时依赖和开发时依赖，避免将开发依赖误放入 `dependencies`
- **锁文件管理**：
  - **必须提交**：锁文件（`pnpm-lock.yaml`、`package-lock.json`、`yarn.lock`）必须提交到版本控制
  - **版本一致性**：确保团队成员使用相同的依赖版本，避免"在我机器上能运行"的问题
  - **定期更新**：定期更新锁文件，保持依赖最新，及时获取安全修复和性能优化

---

## 包命名和结构规范

### 包命名规范
- **Scoped Package**（推荐）：使用作用域包命名（如 `@org/package-name`），避免命名冲突，提高包的可识别性
- **命名原则**：
  - **功能描述清晰**：包名应清晰描述包的功能和用途，便于理解和查找
  - **命名一致性**：保持命名风格一致，使用统一的命名模式（如统一使用 kebab-case）
  - **简洁性原则**：避免过长的名称，保持简洁易读，但不要过度缩写导致含义不清
  - **命名格式**：使用 kebab-case（推荐）或 camelCase（根据项目约定），避免使用下划线和特殊字符
- **命名示例**：
  - ✅ 正确：`@org/utils`、`@org/form-components`、`@org/core`
  - ❌ 错误：`@org/utils_helpers`、`@org/formComponents`、`@org/core-package-for-project`

### 包目录结构
```
packages/[package-name]/
├── src/              # 源代码目录
│   ├── index.ts      # 主入口文件
│   └── ...           # 其他源文件
├── dist/             # 构建产物（不提交）
├── package.json      # 包配置
├── tsconfig.json     # TypeScript 配置
├── vite.config.ts    # 构建配置（可选）
└── README.md         # 包文档
```

### 包入口规范
- **主入口**：
  - **文件位置**：`src/index.ts` 作为主入口文件，统一导出所有公共 API
  - **导出原则**：避免在模块外部直接导入模块内部文件，通过 `index.ts` 统一管理模块的对外接口
  - **封装性**：隐藏内部实现细节，只暴露必要的公共 API，提高包的封装性和可维护性
  - **参考规范**：详细要求请参考 000 规范中的"模块入口规范"章节
- **类型导出**：
  - **导出方式**：通过 `package.json` 的 `exports.types` 字段声明类型文件路径
  - **类型生成**：确保类型文件在构建时正确生成（使用 `vite-plugin-dts`、`rollup-plugin-dts` 等工具）
  - **路径配置**：类型文件路径必须正确指向 `dist/` 目录中的类型声明文件
  - **类型完整性**：确保所有公共 API 都有对应的类型定义，提供完整的类型支持
- **样式导出**：
  - **导出方式**：通过 `package.json` 的 `exports` 字段声明样式文件路径（如 `./style.css`）
  - **按需导入**：支持按需导入样式文件，避免全量导入导致样式文件过大
  - **单独导出**：样式文件应单独导出，便于按需使用和 Tree Shaking
  - **样式组织**：保持样式文件结构清晰，便于维护和扩展
- **多入口支持**：
  - **入口点定义**：可通过 `exports` 字段定义多个入口点，支持不同的使用场景
  - **字段声明**：每个入口点应明确指定 `types`、`import`、`require`、`default` 等字段
  - **命名规范**：保持入口点命名清晰，准确反映其用途（如 `./resolver`、`./utils`）
  - **向后兼容**：新增入口点时，确保不影响现有入口点的使用

---

## 包依赖关系规范

### 依赖声明
- **内部依赖**：参考"依赖管理"章节中的"内部依赖"部分
- **外部依赖**：参考"依赖管理"章节中的"外部依赖"部分
- **开发依赖**：参考"依赖管理"章节中的"开发依赖"部分

### 依赖顺序
- **构建顺序**（关键原则）：
  - **依赖关系顺序**：必须按照依赖关系顺序构建（从底层到上层），确保被依赖的包先构建完成
  - **构建工具支持**：使用构建工具自动处理依赖顺序（如 pnpm filter、npm-run-all、Turborepo）
  - **构建状态检查**：构建失败时，优先检查依赖包的构建状态，确保依赖包构建成功
  - **并行构建优化**：在保证依赖顺序的前提下，充分利用并行构建能力，提升构建速度
- **发布顺序**（关键原则）：
  - **依赖关系顺序**：必须按照依赖关系顺序发布（从底层到上层），确保依赖包先发布
  - **发布前验证**：发布前确保依赖包已成功发布到注册表（npm、私有 registry 等）
  - **自动化工具**：使用发布工具自动处理依赖顺序和版本更新（如 changesets、Lerna、Rush）
  - **版本验证**：发布后验证依赖包版本是否正确更新，确保版本号匹配
  - **回滚策略**：如果发布失败，需要按照相反顺序回滚已发布的包

### 循环依赖
- **禁止循环依赖**（强制要求）：
  - **原则**：包之间绝对不能形成循环依赖，这会导致构建失败、类型解析错误等问题
  - **检测方法**：使用工具（如 `pnpm why`、`madge`）检查依赖关系，及时发现循环依赖
  - **解决方案**：如果发现循环依赖，需要重构代码，提取公共逻辑到共享包，或调整依赖关系
- **依赖图管理**：
  - **依赖关系图**：保持清晰的依赖关系图，使用有向无环图（DAG）结构
  - **依赖分析工具**：使用工具（如 `pnpm why <package>`、`pnpm list`）分析依赖关系
  - **定期审查**：定期审查依赖关系，移除不必要的依赖，优化依赖结构
  - **文档化**：在项目文档中记录依赖关系图，便于团队成员理解和维护

---

## TypeScript 配置规范

### 项目引用（Project References）
- **使用 TypeScript Project References** 管理包之间的类型依赖
- **配置原则**：
  - 根目录配置基础 `tsconfig.json`，定义共享配置
  - 各包继承基础配置，启用 `composite: true`
  - 通过 `references` 字段声明依赖关系
  - 使用 `tsBuildInfoFile` 指定增量编译信息文件路径
  - 确保类型检查时能正确解析跨包类型引用

### 类型定义导出
- **导出方式**：
  - 通过 `package.json` 的 `exports.types` 字段
  - 确保类型文件路径正确指向 `dist/` 目录
- **生成方式**：
  - 构建时自动生成（使用 `vite-plugin-dts`、`rollup-plugin-dts` 等）
  - 生成 `.d.ts` 和 `.d.ts.map` 文件
- **类型文件位置**：
  - 类型文件位于 `dist/` 目录
  - 保持与源码结构一致的目录结构
- **类型引用**：
  - 通过 TypeScript Project References 管理包之间的类型依赖
  - 确保类型定义在包之间正确传递

---

## 构建和发布规范

### 构建配置
- **构建工具选择**：
  - **推荐工具**：Vite（快速、现代化）、Rollup（库构建专用）、Webpack（复杂场景）
  - **选择原则**：根据项目需求选择合适的构建工具，优先考虑构建速度和产物质量
- **构建模式**：
  - **库模式**：使用库模式（Library Mode）构建，而非应用模式
  - **输出格式**：优先输出 ES 模块格式（ESM），兼容性要求高时可同时输出 UMD 格式
  - **格式选择**：ESM 格式支持 Tree Shaking，UMD 格式兼容性更好，根据使用场景选择
- **外部依赖处理**（关键配置）：
  - **external 配置**：使用 `external` 配置，将所有外部依赖标记为外部依赖，避免打包
  - **标记范围**：将 `peerDependencies` 和内部依赖（workspace 包）都标记为外部依赖
  - **优势**：减少构建产物体积，避免依赖重复打包，提高构建速度
  - **注意事项**：确保使用者已安装所有 `peerDependencies`，避免运行时错误

### 构建产物
- **输出目录**：`dist/`（每个包的 `dist/` 目录都应在 `.gitignore` 中排除）
- **Git 忽略配置**：
  - 在根目录 `.gitignore` 中添加 `**/dist/` 或 `packages/*/dist/`
  - 确保所有包的构建产物目录都被排除，不提交到版本控制
- **包含文件**：`.js`、`.d.ts`、`.d.ts.map`、样式文件等
- **文件组织**：
  - 保持与源码结构一致的目录结构
  - 确保构建产物可以直接使用
  - 样式文件单独输出，支持按需导入

### 发布流程
- **发布前检查**（必须执行）：
  - **自动构建**：自动执行 `prepublishOnly` 钩子，执行构建和类型检查，确保代码质量
  - **测试验证**：确保所有测试通过，包括单元测试、集成测试等
  - **版本检查**：检查版本号是否正确更新，确保版本号符合语义化版本规范
  - **依赖检查**：检查依赖版本是否正确，确保内部依赖版本已更新（如果被依赖包版本变化）
  - **文档同步**：确保文档与代码实现保持同步（参考 000 规范中的"文档同步机制"章节）
- **版本管理**：
  - **版本格式**：必须遵循语义化版本（SemVer）规范（详细要求请参考 000 规范中的"版本管理规范"章节）
  - **版本策略选择**：
    - **独立版本**：每个包独立管理版本号，适用于包之间相对独立的场景
    - **统一版本**：所有包共享版本号，适用于包之间紧密耦合的场景
    - **选择原则**：根据项目实际情况和包之间的耦合程度选择合适的版本策略
- **发布顺序**（关键原则）：
  - **依赖顺序**：必须按照依赖顺序发布（从底层到上层），确保依赖包先发布
  - **版本验证**：发布后验证依赖包版本是否正确更新，确保版本号匹配
  - **自动化工具**：使用发布工具（如 changesets、Lerna、Rush）自动处理依赖顺序和版本更新
  - **发布日志**：记录发布日志，包括发布版本、变更内容、发布时间等信息

---

## 开发工作流规范

### 根目录脚本配置
- **多包脚本管理**：在项目根目录的 `package.json` 中添加运行或打包多个包的脚本，方便统一管理
- **脚本示例**：
  ```json
  {
    "scripts": {
      "dev": "run-p \"dev:packages\" \"dev:playground\"",
      "dev:packages": "pnpm --filter \"./packages/*\" dev",
      "build:packages": "pnpm --filter \"./packages/*\" build",
      "publish:all": "run-s publish:package-a publish:package-b publish:package-c"
    }
  }
  ```
- **脚本工具**：
  - **推荐混用**：`npm-run-all` 和 filter 功能配合使用是最佳实践
    - **filter 功能**：用于选择要操作的包（批量或单个包）
    - **npm-run-all**：用于控制多个任务的执行顺序（并行 `run-p` 或串行 `run-s`）
    - **配合示例**：
      - `run-p "dev:packages" "dev:playground"` - 并行执行多个 filter 任务
      - `run-s publish:package-a publish:package-b` - 串行执行多个 filter 任务
      - `pnpm --filter "./packages/*" dev` - 使用 filter 批量操作所有包
  - **备选方案**：`concurrently` 等工具也可用于并行执行，但 `npm-run-all` 更轻量且功能完善
- **脚本命名规范**：
  - 使用统一的命名前缀（如 `dev:`、`build:`、`publish:`）
  - 明确区分单个包操作和批量操作
  - 保持脚本名称清晰易懂
- **脚本组织原则**：
  - 将常用脚本放在根目录，便于快速执行
  - 为每个包提供独立的脚本命令（如 `publish:package-a`、`publish:package-b`）
  - 使用组合脚本简化复杂操作流程

### 开发环境
- **本地开发**：
  - **Watch 模式**：使用 watch 模式自动构建，文件变更时自动重新构建，提高开发效率
  - **并行构建**：支持并行构建多个包，充分利用多核 CPU，提升构建速度
  - **路径别名**：使用路径别名直接引用源码，避免频繁构建，支持实时查看代码变更
  - **开发体验**：配置合理的构建策略，平衡构建速度和开发体验
- **测试环境**：
  - **Playground 应用**：使用 playground 或示例应用进行功能测试，模拟真实使用场景
  - **环境一致性**：确保测试环境与实际使用环境一致，包括依赖版本、构建配置等
  - **集成测试**：在 playground 中进行集成测试，验证包之间的协作是否正常
- **热更新（HMR）**：
  - **源码引用**：通过路径别名直接引用源码，支持 HMR，代码变更时自动更新
  - **别名配置**：在构建工具（Vite、Webpack 等）中配置别名解析，确保开发时使用源码
  - **生产构建**：生产构建时使用构建产物，确保构建产物正确性和性能
  - **配置分离**：开发环境和生产环境使用不同的配置，避免配置冲突

### 调试技巧
- **依赖调试**：
  - 使用 `pnpm why <package>` 或类似命令查看依赖关系
  - 检查依赖版本冲突和重复安装
- **构建调试**：
  - 使用构建工具的详细日志模式（如 `--verbose`）
  - 检查构建顺序和依赖关系
- **类型调试**：
  - 使用 TypeScript 的 `--traceResolution` 查看类型解析过程
  - 检查 Project References 配置是否正确

---

## 最佳实践和注意事项

### 性能优化
- **构建缓存**：
  - **缓存机制**：充分利用构建工具的缓存机制（如 Vite 的缓存、TypeScript 的增量编译）
  - **缓存策略**：合理配置缓存策略，避免不必要的重复构建，提升构建速度
  - **缓存清理**：定期清理无效缓存，确保构建结果的正确性
- **依赖优化**：
  - **依赖清理**：定期清理未使用的依赖，减少依赖体积和安装时间
  - **依赖分析**：使用 `pnpm why <package>` 或类似工具分析依赖树，识别不必要的依赖
  - **依赖版本**：保持依赖版本更新，及时获取性能优化和安全修复
- **并行构建**：
  - **并行策略**：充分利用并行构建能力，提升整体构建速度
  - **依赖顺序**：注意构建顺序，确保依赖包先构建完成，避免构建失败
  - **资源利用**：合理配置并行任务数量，平衡构建速度和系统资源占用

### CI/CD 集成
- **构建流程**：在 CI 中按照依赖顺序构建所有包，使用缓存机制加速构建过程
- **测试流程**：为每个包运行独立的测试套件，确保测试环境与实际使用环境一致
- **发布流程**：自动化版本管理和发布流程，使用发布工具（如 changesets）管理版本变更

---
