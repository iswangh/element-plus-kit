---
description: 前端项目通用开发规范
globs: 
alwaysApply: true
---

# 前端项目通用开发规范

> **⚠️ 重要提示：本文档为强制规范文件**
> 
> - **必须严格遵循**：本文档中的所有规范均为强制性要求，必须严格遵守，不得违反（详细要求请参考"响应原则"章节中的"规则文件严格遵循"部分）
> - **配置文件优先**：执行任何操作前，必须先查询并理解相关的配置文件（详细要求请参考"工具使用规范"章节中的"配置文件查询规范"部分）

## 标记系统说明

本文档使用以下标记系统标识规范的强制程度：

- **`[强制]`**：必须强制要求遵循的规范，不得违反
- **无标记**：建议性规范，应尽量遵循

> **⚠️ 重要说明**：
> - 在"沟通响应规范"章节中，所有内容都是强制要求，因此在章节开头统一说明，不再为每个子项单独标记
> - 在其他章节中，只有明确标记 `[强制]` 的规范才是强制要求，其他为建议性规范

## [强制] 沟通响应规范

> **⚠️ 强制要求**：本章节下的所有内容都是强制性的，必须严格遵守。本章节中的所有规范都是必须强制要求遵循的，不存在可选或建议性的内容。

### 语言使用

- **始终使用简体中文**：与用户进行沟通交流时，确保信息传达清晰准确
- **中文编码规范**：
  - **必须使用 UTF-8 编码**：所有中文内容必须使用 UTF-8 编码，确保正确显示
  - **避免乱码**：确保中文内容正确显示，不得出现乱码、问号或其他异常字符
  - **编码检查**：在返回中文内容前，必须检查编码是否正确，确保中文能够正确显示
  - **文件编码**：所有包含中文的文件必须使用 UTF-8 编码保存
- **技术术语保持英文原文**：避免翻译造成的歧义（如：API、DOM、Promise、React Hook 等）
- **术语解释策略**：解释技术概念时，优先使用业界通用术语，必要时辅以中文解释；对于复杂概念，可先给出中文解释，再提供英文术语对照
- **代码语言规范**：
  - 代码中的变量、函数、类名等标识符使用英文命名
  - 代码注释可使用中文，便于理解（遵循项目的注释规范）
  - 代码示例中的字符串字面量根据实际业务场景选择语言
- **错误信息规范**：错误提示信息使用中文，便于用户理解；技术错误代码和标识符保持英文原文，确保技术准确性

### 响应原则

- **规则文件严格遵循**（最高优先级）：
  - **必须严格遵循**：每次回答必须严格根据本文档执行，所有操作和建议必须符合本文档的要求
  - **不得违反**：不得以任何理由违反本文档中的任何规范
  - **优先级最高**：本文档的优先级高于其他任何规范、约定或用户临时要求
  - **执行前必读**：在执行任何操作前，必须先阅读并理解本文档的相关章节
  - **规则文件动态读取**（强制要求，必须严格执行）：
    - **执行要求**：这是最高优先级的强制要求，每次响应前必须首先执行，不得遗漏、不得跳过、不得延迟
    - **读取时机**：每次响应开始时，在声明规则文件之前，必须先重新读取所有最新的规则文件
    - **读取目的**：确保使用最新的规则文件内容，防止规则文件更新后仍使用旧版本规则进行响应
    - **读取范围**：必须读取项目中的所有相关规则文件（如 `@000_frontend-development-standards.mdc`、`@001_monorepo_development-standards.mdc`、`@002_project_rules.mdc` 等）
    - **读取方式**：使用 `read_file` 工具主动读取所有规则文件，确保获取最新内容
    - **读取顺序**：按照规则文件的编号顺序读取（000 → 001 → 002），确保依赖关系正确
    - **缓存处理**：不得依赖缓存的规则文件内容，必须每次重新读取，确保内容最新
    - **读取验证**：读取后应验证规则文件的完整性和有效性，确保规则文件格式正确
    - **执行检查**：每次响应前，必须检查是否已执行规则文件动态读取；如果未执行，必须立即补充读取后再继续响应
    - **违规后果**：未执行规则文件动态读取被视为严重违规，必须立即纠正
  - **规则文件声明**（强制要求，必须严格执行）：
    - **执行要求**：这是最高优先级的强制要求，在完成规则文件动态读取后，必须立即执行规则文件声明，不得遗漏、不得跳过、不得延迟
    - **执行顺序**：规则文件声明必须在规则文件动态读取之后执行，确保声明的是已读取的最新规则文件
    - **声明时机**：每次回答开始时，在完成规则文件动态读取后，必须在回答内容的最开始（在回答具体问题之前）明确声明将严格遵循的规则文件列表
    - **声明位置**：必须在回答的第一行或第二行（紧跟在任何问候语之后）立即声明，不得放在回答中间或末尾
    - **声明目的**：通过明确声明需要遵循的规则文件，提高 AI 助手的记忆和一致性，确保所有回答都符合项目规范
    - **声明格式**：使用以下统一格式声明（必须严格遵循此格式，不得修改）：
      ```
      以下回答都将严格遵循以下规则文件：
      {规则文件1的名称}
      {规则文件2的名称}
      ...
      ```
    - **声明要求**（必须全部满足）：
      - **必须使用 `@` 符号引用规则文件**（如 `@000_frontend-development-standards.mdc`），不得使用其他格式
      - **每个规则文件占一行**，保持格式清晰，不得合并在一行
      - **必须包含项目实际使用的所有相关规则文件**，不得遗漏任何规则文件
      - **声明后必须立即开始回答具体问题**，不得在声明后添加其他无关内容
    - **声明示例**：
      - 对于当前项目（monorepo-project），必须声明：
        ```
        以下回答都将严格遵循以下规则文件：
        @000_frontend-development-standards.mdc
        @001_monorepo_development-standards.mdc
        @002_project_rules.mdc
        ```
      - 对于其他项目，应根据项目实际使用的规则文件进行声明，确保声明完整准确
    - **执行检查**：每次回答前，必须检查是否已执行规则文件声明；如果未执行，必须立即补充声明后再继续回答
    - **违规后果**：未执行规则文件声明被视为严重违规，必须立即纠正
  - **规则文件校验**：每次回答后，必须根据本文档进行校验，检查回答内容是否符合要求；如果不符合，必须重新执行并修正，直到完全符合要求
- **配置文件查询规范**：
  - **执行前必查**：在执行任何操作前，必须先查询并理解相关的配置文件
  - **详细规范**：具体查询要求和操作步骤请参考"工具使用规范"章节中的"配置文件查询规范"部分
- **上下文理解**：充分理解用户需求，结合项目上下文、相关文件、配置文件等进行分析和回答
- **专业准确**：提供专业、准确的技术建议和解决方案，确保建议具有实用性和可操作性
- **理由说明**：在给出建议时，明确说明理由和适用场景，帮助用户理解技术选型和实现思路
- **主动调研**：遇到不确定的问题时，主动查阅代码库、配置文件或相关文档，确保回答的准确性
- **优先级处理**：先回答核心问题，再补充细节和扩展说明，确保关键信息优先传达
- **完整性保障**：提供完整、可执行的解决方案，包括必要的代码示例、配置说明和注意事项，避免碎片化回答
- **方案对比**：当存在多种实现方案时，对比分析各方案的优缺点，并推荐最适合当前场景的方案
- **不确定处理**：对于无法确定或超出能力范围的问题，明确说明不确定的原因，提供可能的解决方向或建议查阅的文档
- **自我检查**：回答完成后，立即对回答内容进行检查、纠错和修复，确保信息准确无误
- **文档同步检查**：每次回答后，必须检查是否存在相关的文档，如果存在，必须同步更新文档内容（请参考"文档同步机制"章节）
- **MDC 文件生成规范**：基于现有 MDC 规则文件和项目上下文生成新的 MDC 文件时，必须避免生成重复内容
  - **用途说明**：MDC 文件主要用于与 AI 助手沟通使用，这是 MDC 文件的核心用途，需要重点关注
  - **重复内容检查**：生成前必须检查现有 MDC 文件（如 000、001 等）中是否已包含相同或类似的内容
  - **内容策略**：
    - **禁止完全重复**：新文件不应包含与现有文件完全相同的内容
    - **允许补充**：可以补充现有文件未涵盖的内容
    - **允许覆盖**：可以覆盖或细化现有文件中的内容，但需明确说明覆盖原因
  - **引用策略**：对于已在现有文件中定义的内容，应使用引用（如"参考 000 规范"、"参考 001 规范"）而非重复描述
  - **示例**：如果已有 000（通用前端规范）和 001（Monorepo 通用规范），生成 002（项目特定规范）时，不应重复 000 和 001 中的通用内容，而应专注于项目特定的规则和补充说明
- **Git 提交信息**：
  - **执行时机**：每次回答完成后，必须自动检查是否存在暂存的更改
  - **检查方式**：使用 `git status --short` 或类似命令自动扫描暂存的文件
  - **文件分析**：如果存在暂存文件，必须读取并分析所有暂存文件的内容变更
  - **提交信息生成**：基于所有暂存文件的变更内容，生成一个综合的、符合 Conventional Commits 规范的 git 提交信息
  - **提交信息要求**：
    - 必须涵盖所有暂存文件的变更内容
    - 必须使用正确的提交类型（`feat`、`fix`、`docs`、`style`、`refactor`、`test`、`chore` 等）
    - 必须包含清晰的主题描述，准确反映所有变更的核心内容
    - 如果涉及多个类型的变更，应选择最主要的类型，或在描述中说明
  - **提交信息格式**：遵循约定式提交（Conventional Commits）格式：`<type>(<scope>): <subject>`（详细格式要求请参考"版本控制规范"章节）
  - **执行方式**：自动执行，无需用户交互，在回答末尾提供提交信息建议（**注意**：提交信息应在时间信息之前显示）
- **变更影响分析**：修改代码前，分析变更的影响范围，包括依赖的文件、相关的测试、文档等
- **错误预防**：在提供解决方案时，主动识别可能的错误场景，并提供预防措施
- **可回滚性**：对于重要变更，提供回滚方案或说明如何撤销变更
- **时间返回规范**：
  - **必须返回当前时间**：每次回答完成后，必须返回当前系统时间
  - **时间格式**：精确到年月日时分秒，格式为：`YYYY-MM-DD HH:mm:ss`（如：`2025-11-12 13:18:28`）
  - **时间来源**：
    - **必须使用真实的系统时间**：必须通过系统工具或命令获取当前真实时间
    - **禁止手动设置**：禁止手动输入时间、禁止使用固定时间、禁止使用错误的时间
    - **禁止使用历史时间**：禁止使用过去的时间或未来的时间，必须使用当前实际时间
    - **时间获取方式**：
      - **自动执行**：时间获取必须自动执行，无需用户交互或等待用户输入
      - **使用系统工具**：应主动使用可用的工具（如 `run_terminal_cmd`）自动调用系统命令获取时间
      - **系统命令示例**：
        - Windows: `powershell -Command "Get-Date -Format 'yyyy-MM-dd HH:mm:ss'"`
        - macOS/Linux: `date '+%Y-%m-%d %H:%M:%S'`
      - **执行时机**：在回答完成前自动执行时间获取命令，确保返回的时间是准确的当前时间
      - **无需用户确认**：时间获取过程应该是静默的、自动的，不需要用户批准或确认
  - **时间位置**：
    - **必须在末尾显示**：时间信息必须在回答内容的最末尾单独显示，不得在任何其他内容之后
    - **优先级最高**：时间信息的位置优先级高于其他所有内容（包括 Git 提交信息、总结、建议等），必须作为回答的最后一行
    - **显示格式**：格式为：`**当前时间**：YYYY-MM-DD HH:mm:ss`
    - **独立显示**：时间信息应单独成行，前后保持适当空行，确保清晰可见
    - **禁止前置**：禁止将时间信息放在回答开头或中间位置，必须严格在末尾
  - **时间验证**：如果无法获取系统时间，应明确说明原因，不得使用虚假或错误的时间
  - **中断处理规范**：
    - **适用范围**：当执行过程中突然中断、取消、遇到错误或异常终止时，必须遵循本规范
    - **中断时也必须返回时间**：无论何种原因导致中断，都必须返回当前系统时间
    - **中断信息记录**：如果是因为网络问题、系统错误、工具调用失败或其他外部因素导致中断，必须记录以下信息：
      - **当前任务**：明确说明正在执行的任务名称和具体内容
      - **任务进度**：详细说明已完成的工作和剩余的工作，使用百分比（如 `3/5 (60%)`）或具体步骤描述（如 `已完成文件 A、B 的修改，正在处理文件 C`）
      - **继续任务起点**：明确指出任务恢复时应从哪个步骤、哪个文件、哪个函数或哪个位置继续执行，提供具体的文件路径和代码位置（如行号）
    - **中断信息格式**：
      ```
      **任务中断**
      - **当前任务**：{任务名称和描述}
      - **任务进度**：{已完成}/{总步骤}（{百分比}%）或 {具体进度描述}
      - **继续起点**：从 {具体位置} 继续执行
      - **中断原因**：{中断原因说明}
      - **当前时间**：YYYY-MM-DD HH:mm:ss
      ```
    - **中断信息位置**：中断信息应在中断响应的最前面显示，时间信息必须在最后显示（作为回答的最后一行）
    - **任务恢复指导**：提供清晰的恢复指导，包括：
      - 需要重新执行的操作步骤
      - 需要检查的文件或配置
      - 可能需要的额外信息或上下文
      - 帮助用户快速恢复任务执行的具体建议

## 开发工具配置

### Node.js 版本管理
- **必须使用 Volta 管理 Node.js 版本**：确保开发环境一致性
- **全局安装要求**：Volta 必须全局安装，在使用前应检查是否已安装
- **检查方式**：执行 `volta --version` 检查是否已安装
- **安装方式**：若未安装，通过官方安装脚本或包管理器进行全局安装
  - Windows: `winget install Volta.Volta` 或使用官方安装脚本
  - macOS/Linux: `curl https://get.volta.sh | bash` 或使用包管理器
- **安装后验证**：安装完成后通过 `volta --version` 确认安装成功
- **版本锁定**：若项目 `package.json` 中未指定 Node.js 版本，执行 `volta pin node@latest` 锁定最新 LTS 版本
- **配置检查**：优先检查项目中是否已存在 Volta 配置，遵循现有配置

### 包管理器选择
- **优先使用 @antfu/ni 智能命令**（推荐）：
  - **全局安装要求**：`@antfu/ni` 必须全局安装，在使用前应检查是否已安装
    - **检查方式**：执行 `ni --version` 或 `which ni` 检查是否已安装
    - **安装方式**：若未安装，执行 `npm install -g @antfu/ni` 进行全局安装
    - **安装后验证**：安装完成后通过 `ni --version` 确认安装成功
  - **使用方式**：
    - 使用 `ni` 安装依赖（自动识别项目锁文件）
    - 使用 `nr` 运行 package.json 中的脚本命令
    - 自动识别项目锁文件类型（bun.lockb、pnpm-lock.yaml、package-lock.json、yarn.lock）
- **降级方案**：若 `ni` 不可用，使用 **npm** 作为备选包管理器
- **锁文件检查**：执行包管理命令前，优先检查项目根目录的锁文件类型，使用对应的包管理器

## 项目架构规范

### 目录结构设计原则
- **分层架构**：按业务领域或功能模块划分目录，严格遵循关注点分离原则
- **命名一致性**：采用描述性命名，目录和文件名需清晰反映其用途和职责
- **模块化设计**：
  - 相关功能聚合到同一模块，保持高内聚
  - 最小化跨模块依赖，降低耦合度
  - 每个模块职责明确，边界清晰
- **模块入口规范**：
  - 每个模块必须包含 `index.ts`（或 `index.tsx`）作为聚合导出入口
  - 避免在模块外部直接导入模块内部文件
  - 通过 `index.ts` 统一管理模块的对外接口
- **层级控制**：
  - 目录嵌套深度不超过 5-6 层，保持结构清晰可维护
  - 避免过深的嵌套导致路径冗长和导航困难
- **资源分类**：
  - 严格区分源代码（`src/`）、静态资源（`public/` 或 `assets/`）、配置文件（`configs/`）和测试文件（`tests/` 或 `__tests__/`）
- **依赖管理**：具体规范请参考"依赖管理规范"章节
- **环境变量管理**：
  - 使用 `.env` 文件管理环境变量（`.env.local`、`.env.development`、`.env.production` 等）
  - 敏感信息处理请参考"安全规范"章节
  - 在 `.gitignore` 中忽略 `.env.local` 等包含敏感信息的文件
  - 提供 `.env.example` 文件作为环境变量模板
- **约定优先原则**：
  - **第一优先级**：优先遵循项目现有的结构和命名约定
  - **第二优先级**：采用框架官方推荐的项目结构
  - **第三优先级**：参考行业最佳实践

## 代码开发准则

### 代码质量标准
- **可测试性**：
  - 组件保持单一职责原则（SRP）
  - 业务逻辑与视图层分离，便于单元测试
  - 函数保持纯函数特性，避免副作用
- **DRY 原则**（Don't Repeat Yourself）：
  - 提取公共逻辑为独立的工具函数或工具类
  - 消除代码重复，提升可维护性
  - 公共逻辑放置在 `utils/` 或 `helpers/` 目录
- **简洁性**：
  - 遵循 KISS 原则（Keep It Simple, Stupid）
  - 避免过度设计和过早优化
  - 优先选择简单、直接的实现方案
- **语义化命名**：
  - **准确描述**：变量、函数、类名需准确描述其用途和含义
  - **有意义命名**：使用有意义的命名，避免缩写和单字母变量（循环计数器除外）
  - **布尔值前缀**：布尔值使用 `is`、`has`、`should` 等前缀，提高可读性

### TypeScript 类型规范
- **类型定义原则**：
  - **优先使用类型推断**：充分利用 TypeScript 的类型推断能力，避免不必要的类型注解，保持代码简洁
- **命名规范**：
  - 变量、函数使用 `camelCase`
  - 类、接口、类型别名、枚举使用 `PascalCase`
  - 常量使用 `UPPER_CASE`
  - 私有成员可使用 `_` 前缀（如 `_privateMethod`）
- **接口与类型选择**：
  - 优先使用 `interface` 定义对象类型，便于扩展
  - 使用 `type` 定义联合类型、交叉类型或复杂类型
  - 避免定义空接口，除非用于扩展或标记
- **类型安全**：
  - 启用严格模式（`strict: true`）
  - 充分利用类型系统的优势，减少运行时错误
  - 为第三方库缺失的类型定义添加类型声明文件

### 代码风格一致性
- **严格遵循项目配置的代码规范**：遵循项目配置的代码规范工具（ESLint、Prettier 等）的规则
- **遵循项目特定的代码风格规则**：遵循项目特定的代码风格规则和约定
- **保持整个项目的代码风格统一**：确保整个项目的代码风格保持一致，避免风格混用

### 代码实现优先级
- **最优方案选择**：优先选用极简、优雅、性能三者兼具的实现方案
- **实现优先级排序**：
  1. **极简性**：代码简洁、易读、易理解
  2. **代码优雅**：结构清晰、逻辑合理、符合设计模式
  3. **性能优化**：在保证前两者的基础上，考虑性能优化
- **避免过度优化**：不要为了微小的性能提升而牺牲代码可读性

### 注释编写规范

#### JSDoc 标准
所有变量、函数、类、接口的类型定义必须使用 **JSDoc 格式**进行注释，确保类型信息和文档说明清晰完整

#### 注释类型与格式

**1. 简单注释**（仅有标题时）
```typescript
/** 用户服务类 */
```

**2. 详细注释**（需要描述说明时）
```typescript
/**
 * 用户服务类
 *
 * 负责用户相关的业务逻辑处理，包括注册、登录、信息管理等核心功能
 */
```

**3. 参数注释**（有参数或返回值时）
```typescript
/**
 * 获取用户信息
 * @param {string} userId - 用户唯一标识符
 * @returns {User} 用户对象，包含用户基本信息
 */
```

**4. 完整注释**（既有描述又有参数时）
```typescript
/**
 * 用户登录验证
 *
 * 通过用户名和密码进行用户身份验证，验证成功返回用户令牌。
 * 支持多种认证方式，包括普通登录和第三方登录。
 *
 * @param {string} username - 用户名或邮箱
 * @param {string} password - 用户密码（已加密）
 * @returns {Promise<string>} JWT 令牌字符串
 * @throws {AuthError} 当用户名或密码错误时抛出认证异常
 */
```

**5. 行内注释**（函数内部逻辑说明）
```typescript
// 验证用户权限，确保只有管理员可以访问
if (!hasPermission) {
  throw new Error('权限不足');
}
```

**6. 类型定义注释**（Interface 和 Type 定义）
```typescript
/**
 * API 统一响应接口
 * @template T 响应数据的类型
 */
interface APIResponse<T> {
  /** 响应状态码 */
  code: number;
  /** 响应数据 */
  data: T;
  /** 响应消息 */
  message: string;
}
```

#### 注释编写原则
- **必要性**：代码本身能表达清楚的逻辑，无需添加注释；仅在必要时添加注释
- **准确性**：注释内容必须与代码实现保持一致，确保注释准确反映代码行为
- **及时性**：修改代码时同步更新相关注释，保持注释与代码同步
- **简洁性**：注释简洁明了，避免冗余和废话，突出关键信息

## 工程化实践

### 技术选型原则
- **成熟稳定优先**：优先选用经过验证、社区活跃的成熟解决方案
- **评估标准**：考虑维护状态、社区支持、文档完整性、性能表现等因素

### 架构设计原则
- **可维护性**：代码结构清晰，便于理解和修改
- **可扩展性**：预留扩展点，支持未来功能迭代
- **性能优化**：在保证代码质量的前提下，考虑性能优化

### 版本控制规范
- **说明**：版本控制规范主要涉及 Git 提交信息和分支管理，与版本管理规范（package.json 版本号）不同，请勿混淆
- **提交信息规范**：
  - **格式要求**：遵循约定式提交（Conventional Commits）格式：`<type>(<scope>): <subject>`
  - **提交类型**：`feat`（新功能）、`fix`（Bug 修复）、`docs`（文档）、`style`（格式）、`refactor`（重构）、`test`（测试）、`chore`（构建/工具）等
  - **破坏性变更**：如果提交包含破坏性变更，需要在提交信息中使用 `BREAKING CHANGE:` 标记
- **分支管理**：
  - 遵循项目的分支策略（如 Git Flow、GitHub Flow）
  - 保持主分支（main/master）代码始终可运行
  - 功能开发使用特性分支，合并前需进行代码审查

### 版本管理规范

#### 版本格式要求
- **必须使用语义化版本（Semantic Versioning，SemVer）**：这是前端项目版本管理的唯一标准
- **版本格式**：`MAJOR.MINOR.PATCH`（如 `1.2.3`）
  - **MAJOR**（主版本号）：不兼容的 API 修改时递增
  - **MINOR**（次版本号）：向下兼容的功能性新增时递增
  - **PATCH**（修订号）：向下兼容的问题修正时递增
- **版本号示例**：`1.2.3`、`2.0.0`、`0.0.0` 等

#### package.json 版本字段规范
- **版本字段位置**：`package.json` 中的 `version` 字段
- **版本号格式**：必须符合语义化版本（SemVer）规范，使用字符串格式（如 `"1.0.0"`）
- **开发阶段版本**：
  - **初始开发**：使用 `"0.0.0"` 表示项目处于初始开发阶段，尚未发布正式版本
  - **预发布版本**：可以使用预发布标识符（如 `"1.0.0-alpha.1"`、`"1.0.0-beta.1"`、`"1.0.0-rc.1"`）
  - **正式版本**：从 `"1.0.0"` 开始，表示项目已稳定，API 已确定
- **私有项目**：如果项目标记为 `"private": true`，可以使用 `"0.0.0"` 或开发版本号，无需遵循严格的版本管理

#### 版本更新策略
- **主版本号（MAJOR）**：当进行不兼容的 API 修改时递增
  - 示例：`1.0.0` → `2.0.0`
  - 触发场景：
    - 删除或重命名公共 API
    - 改变默认行为或配置
    - 移除已废弃的功能
    - 重大架构变更导致不兼容
  - **注意事项**：主版本更新应谨慎，尽量通过废弃（deprecation）机制平滑过渡
- **次版本号（MINOR）**：当添加向下兼容的新功能时递增
  - 示例：`1.0.0` → `1.1.0`
  - 触发场景：
    - 新增功能或 API
    - 新增配置选项
    - 新增组件或工具函数
    - 增强现有功能（不改变现有行为）
  - **注意事项**：新功能应保持向后兼容，不影响现有代码
- **修订号（PATCH）**：当进行向下兼容的问题修正时递增
  - 示例：`1.0.0` → `1.0.1`
  - 触发场景：
    - Bug 修复
    - 性能优化（不改变 API）
    - 文档更新和修正
    - 类型定义修正
  - **注意事项**：修复应确保不引入新的破坏性变更

#### 版本更新时机
- **开发阶段**：在开发过程中，版本号可以保持不变（如保持 `"0.0.0"`）
- **功能完成**：完成新功能后，根据变更类型更新版本号
- **发布前**：发布到 npm 或其他包管理器前，必须更新版本号
- **Git 标签**：建议使用 Git 标签标记版本（如 `v1.0.0`），便于版本追踪

#### 版本更新命令
- **使用 npm/pnpm 命令**：
  ```bash
  # 更新修订号（1.0.0 → 1.0.1）
  npm version patch
  # 或
  pnpm version patch
  
  # 更新次版本号（1.0.0 → 1.1.0）
  npm version minor
  # 或
  pnpm version minor
  
  # 更新主版本号（1.0.0 → 2.0.0）
  npm version major
  # 或
  pnpm version major
  ```
- **手动更新**：直接修改 `package.json` 中的 `version` 字段
- **预发布版本**：
  ```bash
  npm version prerelease --preid=alpha
  npm version prerelease --preid=beta
  npm version prerelease --preid=rc
  ```
- **注意事项**：
  - 使用 `npm version` 或 `pnpm version` 命令会自动更新 `package.json` 并创建 Git 提交和标签
  - 手动更新时，需要手动创建 Git 提交和标签
  - 预发布版本用于测试和预览，正式发布前需要发布正式版本

#### 版本号最佳实践
- **初始版本**：
  - 新项目从 `"0.0.0"` 开始
  - `0.x.x` 版本表示 API 尚未稳定，可能随时变更
- **稳定版本**：
  - 当 API 稳定后，发布 `"1.0.0"` 版本
  - `1.0.0` 表示项目已稳定，API 已确定，后续更新遵循语义化版本（SemVer）规范
- **版本一致性**：
  - 确保 `package.json` 中的版本号与 Git 标签、CHANGELOG 等保持一致
  - 使用 Git 标签标记版本（如 `v1.0.0`），便于版本追踪和回滚
  - 在 CHANGELOG 中记录每个版本的变更内容
- **版本说明**：
  - 重大版本更新应在 CHANGELOG 中详细说明变更内容
  - 说明破坏性变更、迁移指南和弃用警告
  - 提供清晰的升级路径和兼容性说明
- **向后兼容**：
  - 尽量保持向后兼容，避免频繁更新主版本号
  - 使用废弃（deprecation）机制标记即将移除的功能
  - 在主版本更新前，至少保留一个次版本周期用于过渡
- **版本发布流程**：
  - 发布前确保所有测试通过
  - 更新版本号后创建 Git 标签
  - 发布到 npm 或其他包管理器
  - 更新 CHANGELOG 和文档

#### 为什么必须使用 SemVer
- **行业标准**：npm、pnpm、yarn 等包管理工具默认支持，大多数开源项目采用，是前端生态系统的通用规范
- **清晰的语义**：版本号直接表达变更类型和兼容性，开发者可以通过版本号快速判断是否需要更新依赖
- **自动化友好**：依赖管理工具可自动处理版本范围（`^`、`~`），CI/CD 可基于版本号自动化发布流程
- **依赖管理**：支持版本范围匹配，自动获取兼容更新和安全修复，同时避免破坏性变更
- **团队协作**：统一的版本管理规范降低沟通成本，提高团队协作效率

### 错误处理规范
- **全面性**：全面处理边界情况和异常状态
- **信息性**：提供有意义的错误信息，便于调试和问题定位
- **用户友好**：向用户展示友好的错误提示，避免暴露技术细节

### 代码修改和重构规范
- **修改前检查清单**：
  - 检查是否有其他代码依赖此部分
  - 检查是否有相关测试需要更新
  - 检查是否有相关文档需要同步（请参考"文档同步机制"章节）
- **修改时注意**：
  - 保持向后兼容性，避免破坏性变更
  - 如果必须进行破坏性变更，明确标注并更新版本号（请参考"版本管理规范"章节）
  - 修改后运行测试确保功能正常
- **重构原则**：
  - 小步重构，每次只改一个方面
  - 重构前确保有测试覆盖
  - 重构后运行完整测试套件
  - 重构时保持功能不变，只改进代码结构
- **删除代码时**：
  - 检查是否有其他地方引用
  - 检查是否有相关测试需要删除或更新
  - 检查是否有相关文档需要更新（请参考"文档同步机制"章节）
  - 如果是公共 API，考虑废弃（deprecate）而不是直接删除

### 文件操作规范
- **创建新文件时**：
  - 遵循项目的目录结构和命名规范
  - 添加必要的文件头注释（如 `@file` 注释）
  - 检查是否需要更新 `index.ts` 等入口文件
  - 检查是否需要添加相关文档（请参考"文档同步机制"章节）
- **删除文件时**：
  - 检查是否有其他文件导入此文件
  - 检查是否需要更新导出文件（如 `index.ts`）
  - 检查是否需要删除相关测试文件
  - 检查是否需要更新相关文档（请参考"文档同步机制"章节）
- **重命名文件时**：
  - 更新所有导入此文件的地方
  - 更新导出文件（如 `index.ts`）
  - 更新相关文档中的引用（请参考"文档同步机制"章节）
  - 使用 IDE 的重构功能确保所有引用都被更新

### 依赖管理规范
- **基本原则**：
  - 统一在 `package.json` 中声明所有依赖，避免分散配置
  - 不使用全局依赖，确保项目依赖可复现
  - 严格区分 `dependencies` 和 `devDependencies`
    - 运行时必需的依赖放入 `dependencies`
    - 仅在开发、构建、测试时需要的依赖放入 `devDependencies`
- **版本锁定策略**：
  - 生产依赖使用精确版本或版本范围锁定（遵循语义化版本（SemVer）规范）
  - 开发依赖可使用 `^` 或 `~` 允许小版本更新（遵循语义化版本（SemVer）规范）
  - 定期更新依赖，关注安全漏洞修复（请参考"安全规范"章节）
- **添加新依赖时**：
  - 评估依赖的必要性和安全性
  - 检查依赖的维护状态和社区活跃度
  - 确认依赖的许可证与项目兼容
  - 添加到正确的分类（`dependencies` 或 `devDependencies`）
  - 记录添加依赖的原因（在提交信息中）
- **更新依赖时**：
  - 查看更新日志，了解变更内容
  - 检查是否有破坏性变更（根据语义化版本（SemVer）规范判断：主版本号变更表示破坏性变更）
  - 运行测试确保兼容性
  - 如果 API 有变化，更新相关文档（请参考"文档同步机制"章节）
- **处理依赖冲突时**：
  - 优先使用项目已使用的版本
  - 如果必须升级，评估影响范围
  - 使用 `pnpm why` 或类似命令分析依赖树
  - 考虑使用 `peerDependencies` 或 `overrides` 解决冲突

### 调试和问题诊断规范
- **错误处理原则**：
  - 仔细阅读错误信息，理解错误原因
  - 使用适当的调试工具（浏览器开发者工具、Node.js 调试工具等）
  - 添加适当的日志输出帮助定位问题
  - 检查边界情况和异常输入
- **编译错误**：
  - 检查类型定义是否正确
  - 检查导入路径是否正确
  - 检查配置文件是否正确
- **类型错误**：
  - 理解类型错误的根本原因
  - 检查类型定义是否完整
  - 考虑是否需要添加类型断言或类型守卫
  - 避免使用 `any`，优先使用正确的类型
- **运行时错误**：
  - 使用浏览器开发者工具查看错误信息
  - 检查控制台是否有警告或错误
  - 使用断点调试定位问题
  - 检查数据格式是否符合预期
  - 使用 try-catch 捕获和处理异常
- **性能问题诊断**：
  - 使用性能分析工具（如 Chrome DevTools Performance）
  - 识别性能瓶颈（渲染、网络、计算等）
  - 优先优化影响最大的部分
  - 避免过早优化，先确保功能正确

### 代码审查规范
- **审查要点**：
  - 代码是否符合项目规范
  - 是否有潜在的安全问题
  - 是否有性能问题
  - 是否有测试覆盖
  - 文档是否同步更新（请参考"文档同步机制"章节）
- **反馈处理**：
  - 认真对待审查反馈
  - 及时修复审查中发现的问题
  - 如果不理解反馈，主动沟通澄清
  - 修复后重新提交审查

### 工具使用规范

> **⚠️ 强制要求**：以下所有规范都是强制性的，必须严格遵守。

- **`[强制]` 配置文件查询规范**（执行前必查）：
  - **脚本执行前**：执行任何脚本命令前，必须先读取 `package.json` 文件，查看 `scripts` 字段：
    - 确认脚本是否存在
    - 确认脚本命令和参数是否正确
    - 确认脚本的依赖关系（如 `pre`、`post` 钩子）
    - 确认脚本的工作目录要求
  - **依赖操作前**：安装、更新、删除依赖前，必须先读取 `package.json` 文件：
    - 查看 `dependencies` 和 `devDependencies` 字段，了解现有依赖
    - 查看 `peerDependencies` 字段，了解对等依赖要求
    - 查看 `engines` 字段，了解 Node.js 版本要求
    - 查看 `volta` 字段（如果存在），了解 Node.js 版本锁定
  - **构建配置前**：修改构建配置前，必须先读取相关的配置文件：
    - `vite.config.ts` 或 `vite.config.js`（Vite 项目）
    - `tsconfig.json` 或 `tsconfig.app.json`（TypeScript 项目）
    - `eslint.config.js` 或 `.eslintrc`（ESLint 配置）
    - `prettier.config.js` 或 `.prettierrc`（Prettier 配置）
  - **环境配置前**：配置环境变量前，必须先读取：
    - `.env.example`（如果存在，了解环境变量模板）
    - `.env` 或 `.env.local`（如果存在，了解当前环境变量）
  - **工具配置前**：配置开发工具前，必须先读取：
    - `.editorconfig`（编辑器配置）
    - `.gitignore`（Git 忽略配置）
    - `.npmrc` 或 `.pnpmrc`（包管理器配置）
  - **查询顺序**：
    1. 项目根目录的配置文件
    2. 当前工作目录的配置文件
    3. 相关子目录的配置文件（如 `packages/*/package.json` 在 Monorepo 项目中）
  - **配置理解**：必须充分理解配置文件的内容，确保操作符合项目配置，不得违反现有配置

- **命令执行前**：
  - **配置文件查询**：必须先查询相关配置文件（请参考"配置文件查询规范"）
  - 确认当前工作目录是否正确
  - 确认命令参数是否正确
  - 确认是否有必要的权限

- **脚本执行规范**：
  - **配置文件查询**：执行脚本前，必须先读取 `package.json` 文件，查看 `scripts` 字段（请参考"配置文件查询规范"）
  - **环境检测**：执行脚本前，必须先检测当前运行环境（如 PowerShell、Bash、CMD 等），根据环境生成对应的命令
  - **命令生成**：根据检测到的环境类型，生成符合该环境语法的命令（如 PowerShell 使用 `$env:` 语法，Bash 使用 `export` 语法）
  - **优先使用智能命令**：运行 package.json 中的脚本命令时，优先使用 `@antfu/ni` 提供的 `nr` 命令（请参考"包管理器选择"章节）
    - 使用 `nr <script-name>` 替代 `npm run <script-name>`、`pnpm run <script-name>` 等
    - `nr` 会自动识别项目锁文件类型，使用对应的包管理器执行脚本
  - **降级方案**：若 `nr` 不可用，根据项目锁文件类型使用对应的包管理器命令（如 `pnpm run <script-name>`、`npm run <script-name>` 等）

- **配置修改时**：
  - **配置文件查询**：修改配置前，必须先读取相关配置文件，理解现有配置（请参考"配置文件查询规范"）
  - 理解配置的作用和影响范围
  - 修改后测试确保配置生效
  - 记录配置变更的原因
  - 更新相关文档（请参考"文档同步机制"章节）

### 安全规范
- **敏感信息处理**：
  - 不在代码中硬编码敏感信息（API 密钥、密码等）
  - 使用环境变量管理敏感信息
  - 确保 `.gitignore` 正确配置，避免提交敏感文件
  - 定期检查代码中是否有泄露的敏感信息
- **依赖安全**：
  - 定期检查依赖的安全漏洞
  - 使用 `pnpm audit` 或类似工具检查
  - 及时更新有安全漏洞的依赖
  - 关注依赖的维护状态

### 兼容性规范
- **浏览器兼容性**：
  - 明确项目支持的浏览器版本
  - 使用 Babel 或类似工具处理兼容性
  - 测试主要浏览器的兼容性
- **版本兼容性**：
  - 明确项目的 Node.js 版本要求
  - 明确项目的包管理器版本要求
  - 在文档中明确说明版本要求

### 代码生成规范
- **生成代码时**：
  - 遵循项目的代码风格和命名规范
  - 添加必要的类型定义和注释
  - 检查生成的代码是否符合项目架构
  - 确保生成的代码可以直接使用，无需手动修改
- **生成组件时**：
  - 遵循组件的命名规范（如 Vue 组件使用 PascalCase）
  - 添加必要的 Props、Emits、Slots 类型定义
  - 添加组件说明注释
  - 检查是否需要添加样式文件
- **生成工具函数时**：
  - 添加 JSDoc 注释说明函数用途
  - 添加类型定义和参数说明
  - 考虑边界情况和错误处理
  - 检查是否需要添加单元测试

### 测试编写规范
- **测试文件组织**：
  - 测试文件与源文件同目录或 `__tests__` 目录
  - 测试文件命名：`*.test.ts`、`*.spec.ts` 或 `*.test.tsx`
  - 测试文件应清晰反映测试的内容
- **测试编写原则**：
  - 每个测试用例只测试一个功能点
  - 测试用例名称清晰描述测试内容
  - 使用描述性的测试描述（describe/it 语句）
  - 测试应该独立，不依赖其他测试的执行顺序
- **测试覆盖**：
  - 核心功能必须有测试覆盖
  - 公共 API 必须有测试覆盖
  - 边界情况和错误处理应该有测试覆盖
  - 优先保证质量，再追求覆盖率

### 常见问题快速参考
- **构建失败**：
  - 检查 Node.js 版本是否符合要求
  - 检查依赖是否正确安装（删除 `node_modules` 重新安装）
  - 检查配置文件是否正确（请参考"调试和问题诊断规范"中的"编译错误"部分）
  - 查看构建日志中的具体错误信息
- **类型错误**：请参考"调试和问题诊断规范"中的"类型错误"部分
- **导入错误**：请参考"调试和问题诊断规范"中的"编译错误"部分（重点检查导入路径、文件存在性、文件扩展名和路径别名配置）
- **运行时错误**：请参考"调试和问题诊断规范"中的"运行时错误"部分

## 文档编写标准

### 通用要求
- **格式统一**：统一使用 Markdown 格式编写文档
- **语言规范**：
  - 语言简洁明了，逻辑清晰
  - 主要使用中文编写，技术术语保留英文原文
- **质量检查**：严格检查拼写和语法错误，确保文档质量

### 文档同步机制

**核心原则**：文档内容必须与代码实现保持同步，这是所有开发活动的必要环节。

- **同步时机**：
  - 修改代码后，必须同步更新相关文档
  - 添加新功能时，必须更新功能文档和 API 文档
  - 修改配置时，必须更新配置说明文档
  - 修复 Bug 时，如果涉及行为变更，必须更新相关文档
- **同步检查流程**：
  1. **识别相关文档**：确定修改内容涉及哪些文档（README.md、API 文档、开发文档、配置文档等）
  2. **检查文档存在性**：使用工具搜索项目中是否存在相关文档
  3. **对比内容一致性**：将代码实现与文档内容进行对比，找出不一致之处
  4. **更新文档内容**：根据代码实现更新文档，确保文档准确反映当前实现
  5. **验证更新完整性**：检查文档更新是否完整，是否遗漏重要信息
- **文档类型识别**：
  - **README.md**：项目概览、快速开始、开发指南
  - **API 文档**：函数、类、接口的类型定义和使用说明
  - **开发文档**：开发流程、配置说明、架构设计
  - **使用指南**：组件使用示例、最佳实践
  - **变更日志**：版本更新、功能变更、Bug 修复
- **同步优先级**：
  1. **高优先级**：API 文档、README.md 中的快速开始和配置说明
  2. **中优先级**：开发文档、使用指南
  3. **低优先级**：变更日志、历史文档

### 文档目录结构
```
项目根目录/
├── README.md           # 项目概览和快速开始指南
├── docs/               # 详细文档目录
│   ├── development/    # 开发文档（按功能模块划分）
│   └── guide/          # 使用指南（按功能模块划分）
```

### README.md 必备内容
- **项目介绍**：项目名称、核心功能、应用场景
- **技术栈说明**：主要技术栈和关键依赖版本
- **目录结构说明**：项目目录结构树状图及说明
- **快速开始**：
  - 环境要求（Node.js 版本等）
  - 安装步骤
  - 开发环境启动
  - 构建和部署
- **开发指南**：开发规范、贡献指南等

### 文档组织规范
- **结构原则**：采用"总-分"结构，从概述到细节，层层递进
- **信息优先级**：关键信息前置，突出重点内容
- **内容组织**：相关内容集中组织，避免信息碎片化
- **格式规范**：
  - 合理使用标题层级（H1-H6），保持层级清晰
  - 使用列表、代码块、表格等元素提升可读性
  - 段落保持简洁，避免大段文字堆砌

### 代码示例标准
- **完整性**：提供完整可执行的代码片段，确保可以直接运行
- **简洁性**：示例代码简洁易懂，突出核心逻辑，避免不必要的复杂性
- **注释说明**：关键部分添加 JSDoc 注释，说明实现思路和注意事项
- **预期说明**：明确说明代码的预期输出和行为效果
- **版本同步**：确保示例代码与当前 API 版本保持同步，及时更新过时示例（请参考"文档同步机制"章节和"版本管理规范"章节）

### 文档维护规范
- **定期审查**：定期审查文档内容，确保与代码实现保持一致（请参考"文档同步机制"章节）
- **变更追踪**：代码变更时，记录需要同步的文档清单（请参考"文档同步机制"章节）
- **版本对应**：文档版本应与代码版本对应（遵循语义化版本（SemVer）规范），重大变更应在文档中明确标注
- **反馈机制**：建立文档反馈机制，及时修复文档中的错误和遗漏
- **自动化检查**：在 CI/CD 流程中集成文档检查，确保文档与代码同步（请参考"文档同步机制"章节）
